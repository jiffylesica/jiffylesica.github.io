<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jiffy Lesica">

<title>Auditing Bias – Jiffy Lesica: Portfolio Junction</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-6de787833effe4777a6777a5e05fb578.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: white;
      }

      .quarto-title-block .quarto-title-banner {
        color: white;
      }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jiffy Lesica: Portfolio Junction</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jiffylesica"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/griffin-lesica/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.instagram.com/jiffylesica/"> <i class="bi bi-instagram" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Auditing Bias</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jiffy Lesica </p>
            </div>
    </div>
      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Goals: 1. Train a machine learning algorithm to predict whether someone is currently employed, based on their other attributes not including gender, and 2. Perform a bias audit of our algorithm to determine whether it displays gender bias.</p>
<p>In this blog post, I trained a machine learning classifier on PUMS data from the state of Connecticut to predict an individual’s employment status based on demographic features. After preparing the data with the folktables library, I experimented with a various classifier models, ultimately deciding on a Random Forest model whose performance I evaluated using metrics like accuracy, Positive Prediction Value, and False Positive/Negative Rates. I then conducted a bias audit by examining false positive rates (FPR), false negative rates (FNR), and positive predictive value (PPV) across the gender groups available in the data - Male and Female. I then plotted feasible FNRs &amp; FPRs to visualize the relationship of error rates between groups, and understand how much one group’s error rate would have to change to match the others. Our results showed notable differences in error rates and PPVs between groups, highlighting areas where the model may inadvertently misclassify women more frequently.</p>
<div id="cell-3" class="cell" data-execution_count="164">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> folktables <span class="im">import</span> ACSDataSource, ACSEmployment, BasicProblem, adult_filter</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>STATE <span class="op">=</span> <span class="st">"CT"</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>data_source <span class="op">=</span> ACSDataSource(survey_year<span class="op">=</span><span class="st">'2018'</span>, </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                            horizon<span class="op">=</span><span class="st">'1-Year'</span>, </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                            survey<span class="op">=</span><span class="st">'person'</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>acs_data <span class="op">=</span> data_source.get_data(states<span class="op">=</span>[STATE], download<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>acs_data.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="164">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">RT</th>
<th data-quarto-table-cell-role="th">SERIALNO</th>
<th data-quarto-table-cell-role="th">DIVISION</th>
<th data-quarto-table-cell-role="th">SPORDER</th>
<th data-quarto-table-cell-role="th">PUMA</th>
<th data-quarto-table-cell-role="th">REGION</th>
<th data-quarto-table-cell-role="th">ST</th>
<th data-quarto-table-cell-role="th">ADJINC</th>
<th data-quarto-table-cell-role="th">PWGTP</th>
<th data-quarto-table-cell-role="th">AGEP</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">PWGTP71</th>
<th data-quarto-table-cell-role="th">PWGTP72</th>
<th data-quarto-table-cell-role="th">PWGTP73</th>
<th data-quarto-table-cell-role="th">PWGTP74</th>
<th data-quarto-table-cell-role="th">PWGTP75</th>
<th data-quarto-table-cell-role="th">PWGTP76</th>
<th data-quarto-table-cell-role="th">PWGTP77</th>
<th data-quarto-table-cell-role="th">PWGTP78</th>
<th data-quarto-table-cell-role="th">PWGTP79</th>
<th data-quarto-table-cell-role="th">PWGTP80</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>P</td>
<td>2018GQ0000191</td>
<td>1</td>
<td>1</td>
<td>302</td>
<td>1</td>
<td>9</td>
<td>1013097</td>
<td>40</td>
<td>90</td>
<td>...</td>
<td>82</td>
<td>39</td>
<td>38</td>
<td>81</td>
<td>0</td>
<td>38</td>
<td>0</td>
<td>0</td>
<td>36</td>
<td>34</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>P</td>
<td>2018GQ0000285</td>
<td>1</td>
<td>1</td>
<td>101</td>
<td>1</td>
<td>9</td>
<td>1013097</td>
<td>70</td>
<td>18</td>
<td>...</td>
<td>69</td>
<td>134</td>
<td>7</td>
<td>70</td>
<td>6</td>
<td>68</td>
<td>141</td>
<td>68</td>
<td>132</td>
<td>145</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>P</td>
<td>2018GQ0000328</td>
<td>1</td>
<td>1</td>
<td>1101</td>
<td>1</td>
<td>9</td>
<td>1013097</td>
<td>17</td>
<td>54</td>
<td>...</td>
<td>37</td>
<td>35</td>
<td>16</td>
<td>16</td>
<td>0</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>18</td>
<td>16</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>P</td>
<td>2018GQ0000360</td>
<td>1</td>
<td>1</td>
<td>905</td>
<td>1</td>
<td>9</td>
<td>1013097</td>
<td>47</td>
<td>18</td>
<td>...</td>
<td>46</td>
<td>48</td>
<td>4</td>
<td>90</td>
<td>87</td>
<td>84</td>
<td>90</td>
<td>3</td>
<td>47</td>
<td>48</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>P</td>
<td>2018GQ0000428</td>
<td>1</td>
<td>1</td>
<td>903</td>
<td>1</td>
<td>9</td>
<td>1013097</td>
<td>35</td>
<td>96</td>
<td>...</td>
<td>32</td>
<td>35</td>
<td>36</td>
<td>71</td>
<td>36</td>
<td>3</td>
<td>37</td>
<td>2</td>
<td>2</td>
<td>35</td>
</tr>
</tbody>
</table>

<p>5 rows × 286 columns</p>
</div>
</div>
</div>
<div id="cell-4" class="cell" data-execution_count="114">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>possible_features<span class="op">=</span>[<span class="st">'AGEP'</span>, <span class="st">'SCHL'</span>, <span class="st">'MAR'</span>, <span class="st">'RELP'</span>, <span class="st">'DIS'</span>, <span class="st">'ESP'</span>, <span class="st">'CIT'</span>, <span class="st">'MIG'</span>, <span class="st">'MIL'</span>, <span class="st">'ANC'</span>, <span class="st">'NATIVITY'</span>, <span class="st">'DEAR'</span>, <span class="st">'DEYE'</span>, <span class="st">'DREM'</span>, <span class="st">'SEX'</span>, <span class="st">'RAC1P'</span>, <span class="st">'ESR'</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>acs_data[possible_features].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="114">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">AGEP</th>
<th data-quarto-table-cell-role="th">SCHL</th>
<th data-quarto-table-cell-role="th">MAR</th>
<th data-quarto-table-cell-role="th">RELP</th>
<th data-quarto-table-cell-role="th">DIS</th>
<th data-quarto-table-cell-role="th">ESP</th>
<th data-quarto-table-cell-role="th">CIT</th>
<th data-quarto-table-cell-role="th">MIG</th>
<th data-quarto-table-cell-role="th">MIL</th>
<th data-quarto-table-cell-role="th">ANC</th>
<th data-quarto-table-cell-role="th">NATIVITY</th>
<th data-quarto-table-cell-role="th">DEAR</th>
<th data-quarto-table-cell-role="th">DEYE</th>
<th data-quarto-table-cell-role="th">DREM</th>
<th data-quarto-table-cell-role="th">SEX</th>
<th data-quarto-table-cell-role="th">RAC1P</th>
<th data-quarto-table-cell-role="th">ESR</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>90</td>
<td>16.0</td>
<td>5</td>
<td>17</td>
<td>1</td>
<td>NaN</td>
<td>1</td>
<td>1.0</td>
<td>4.0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>1.0</td>
<td>2</td>
<td>1</td>
<td>6.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>18</td>
<td>16.0</td>
<td>5</td>
<td>17</td>
<td>2</td>
<td>NaN</td>
<td>1</td>
<td>1.0</td>
<td>4.0</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2.0</td>
<td>2</td>
<td>1</td>
<td>6.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>54</td>
<td>17.0</td>
<td>5</td>
<td>17</td>
<td>1</td>
<td>NaN</td>
<td>1</td>
<td>3.0</td>
<td>4.0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>1.0</td>
<td>1</td>
<td>2</td>
<td>6.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>18</td>
<td>19.0</td>
<td>5</td>
<td>17</td>
<td>2</td>
<td>NaN</td>
<td>3</td>
<td>3.0</td>
<td>4.0</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2.0</td>
<td>1</td>
<td>1</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>96</td>
<td>16.0</td>
<td>2</td>
<td>16</td>
<td>1</td>
<td>NaN</td>
<td>1</td>
<td>3.0</td>
<td>4.0</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>1.0</td>
<td>2</td>
<td>1</td>
<td>6.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<section id="my-version" class="level2">
<h2 class="anchored" data-anchor-id="my-version">My Version</h2>
<div id="cell-6" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-7" class="cell" data-execution_count="124">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>features_to_use1 <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> possible_features <span class="cf">if</span> f <span class="kw">not</span> <span class="kw">in</span> [<span class="st">"ESR"</span>, <span class="st">"SEX"</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-8" class="cell" data-execution_count="125">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>EmploymentProblemSex <span class="op">=</span> BasicProblem(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    features<span class="op">=</span>features_to_use1,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    target<span class="op">=</span><span class="st">'ESR'</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    target_transform<span class="op">=</span><span class="kw">lambda</span> x: x <span class="op">==</span> <span class="dv">1</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    group<span class="op">=</span><span class="st">'SEX'</span>,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    preprocess<span class="op">=</span><span class="kw">lambda</span> x: x,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    postprocess<span class="op">=</span><span class="kw">lambda</span> x: np.nan_to_num(x, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>features, label, group <span class="op">=</span> EmploymentProblemSex.df_to_numpy(acs_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-9" class="cell" data-execution_count="126">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test, group_train, group_test <span class="op">=</span> train_test_split(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    features, label, group, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><em>Convert Folktables data back to Pandas DataFrame for ease of descriptive analysis</em></p>
<div id="cell-11" class="cell" data-execution_count="127">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(X_train, columns <span class="op">=</span> features_to_use1)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"group"</span>] <span class="op">=</span> group_train</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"label"</span>] <span class="op">=</span> y_train</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="how-many-individuals-are-in-the-data" class="level3">
<h3 class="anchored" data-anchor-id="how-many-individuals-are-in-the-data">1. How many individuals are in the data?</h3>
<div id="cell-13" class="cell" data-execution_count="128">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"There are </span><span class="sc">{</span>df<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> individuals in the data for the state of CT"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>There are 29029 individuals in the data for the state of CT</code></pre>
</div>
</div>
</section>
<section id="how-many-individuals-have-a-target-label-1-i.e.-how-many-individuals-are-employed" class="level3">
<h3 class="anchored" data-anchor-id="how-many-individuals-have-a-target-label-1-i.e.-how-many-individuals-are-employed">2. How Many Individuals Have a Target Label == 1 (i.e.&nbsp;How Many Individuals are Employed)?</h3>
<div id="cell-15" class="cell" data-execution_count="129">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Of the </span><span class="sc">{</span>df<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> in the data set, </span><span class="sc">{</span>(df[<span class="st">'label'</span>].mean() <span class="op">*</span> <span class="dv">100</span>)<span class="sc">:.2f}</span><span class="ss">% - or </span><span class="sc">{</span>df[<span class="st">'label'</span>]<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> individuals - are employed"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Of the 29029 in the data set, 48.43% - or 14060 individuals - are employed</code></pre>
</div>
</div>
</section>
<section id="of-the-employed-individuals-how-many-are-male-1-and-how-many-are-female-2" class="level3">
<h3 class="anchored" data-anchor-id="of-the-employed-individuals-how-many-are-male-1-and-how-many-are-female-2">3. Of the Employed Individuals, How Many are Male (1) and How Many are Female (2)?</h3>
<div id="cell-17" class="cell" data-execution_count="130">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>employed_by_group <span class="op">=</span> df.groupby(<span class="st">"group"</span>)[<span class="st">"label"</span>].<span class="bu">sum</span>()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Of the 14060 employed individuals, </span><span class="sc">{</span>employed_by_group<span class="sc">.</span>iloc[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> are male and </span><span class="sc">{</span>employed_by_group<span class="sc">.</span>iloc[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> are female"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Of the 14060 employed individuals, 7169 are male and 6891 are female</code></pre>
</div>
</div>
</section>
<section id="in-each-group-what-proportion-of-individuals-have-target-label-equal-to-1-i.e.-are-employed" class="level3">
<h3 class="anchored" data-anchor-id="in-each-group-what-proportion-of-individuals-have-target-label-equal-to-1-i.e.-are-employed">4. In Each Group, What Proportion of Individuals Have Target Label Equal to 1 (i.e.&nbsp;Are Employed)?</h3>
<div id="cell-19" class="cell" data-execution_count="131">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>proportion_employed_by_group <span class="op">=</span> df.groupby(<span class="st">"group"</span>)[<span class="st">"label"</span>].mean()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"According to the Data,</span><span class="sc">{</span>proportion_employed_by_group<span class="sc">.</span>iloc[<span class="dv">0</span>]<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">% of male individuals are employed and</span><span class="sc">{</span>proportion_employed_by_group<span class="sc">.</span>iloc[<span class="dv">1</span>]<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">% female individuals are employed"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>According to the Data, 51.17% of male individuals are employed and 45.88% female individuals are employed</code></pre>
</div>
</div>
</section>
<section id="intersectional-trends" class="level3">
<h3 class="anchored" data-anchor-id="intersectional-trends">5. Intersectional Trends</h3>
<div id="cell-21" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Since RAC1P Has Values &gt; 2, we must filter to only 1.0 and 2.0</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>df_filtered <span class="op">=</span> df[(df[<span class="st">"RAC1P"</span>] <span class="op">==</span> <span class="fl">1.0</span>) <span class="op">|</span> (df[<span class="st">"RAC1P"</span>] <span class="op">==</span> <span class="fl">2.0</span>)].copy()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Now, we convert RAC1P values to ints to match type</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>df_filtered[<span class="st">"RAC1P"</span>] <span class="op">=</span> df_filtered[<span class="st">"RAC1P"</span>].astype(<span class="bu">int</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Since I want to use categorical labels, and not just numbered labels, we use Pandas map function on a series</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co"># https://pandas.pydata.org/docs/reference/api/pandas.Series.map.html</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>df_filtered[<span class="st">"group"</span>] <span class="op">=</span> df_filtered[<span class="st">"group"</span>].<span class="bu">map</span>({<span class="dv">1</span> : <span class="st">"Male"</span>, <span class="dv">2</span> : <span class="st">"Female"</span>})</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>df_filtered[<span class="st">"RAC1P"</span>] <span class="op">=</span> df_filtered[<span class="st">"RAC1P"</span>].<span class="bu">map</span>({<span class="dv">1</span> : <span class="st">"White"</span>, <span class="dv">2</span> : <span class="st">"Black"</span>})</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>proportion_employed_by_group <span class="op">=</span> df_filtered.groupby([<span class="st">"group"</span>, <span class="st">"RAC1P"</span>])[<span class="st">"label"</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="166">
<pre><code>group   RAC1P
Female  Black    0.466667
        White    0.464758
Male    Black    0.371805
        White    0.535252
Name: label, dtype: float64</code></pre>
</div>
</div>
<div id="cell-22" class="cell" data-execution_count="168">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Using seaborn barplot uses mean as default, which represents the proportional insights we are looking for</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>sns.barplot(df_filtered, x <span class="op">=</span> <span class="st">"group"</span>, y <span class="op">=</span> <span class="st">"label"</span>, hue <span class="op">=</span> <span class="st">"RAC1P"</span>, width<span class="op">=</span><span class="fl">.8</span>, gap<span class="op">=</span><span class="fl">.2</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Intersectional Trends"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="168">
<pre><code>Text(0.5, 1.0, 'Intersectional Trends')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-14-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><em>Training my model with different classifiers</em></p>
<div id="cell-24" class="cell" data-execution_count="134">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Include alternative classifiers from sklearn</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.svm <span class="im">import</span> SVC</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.tree <span class="im">import</span> DecisionTreeClassifier</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestClassifier</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="logistic-regression" class="level2">
<h2 class="anchored" data-anchor-id="logistic-regression">Logistic Regression</h2>
<div id="cell-26" class="cell" data-execution_count="135">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Logistic Regression Classifier (playing with polynomial features)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Discovered we can ass PolynomialFeatures to pipeline!</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PolynomialFeatures</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>model_sex_LR <span class="op">=</span> make_pipeline(PolynomialFeatures(degree <span class="op">=</span> <span class="dv">2</span>), StandardScaler(), LogisticRegression(max_iter<span class="op">=</span><span class="dv">1000</span>))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>model_sex_LR.fit(X_train.copy(), y_train)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>y_hat_LR <span class="op">=</span> model_sex_LR.predict(X_test)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate Overall Values</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>TP_LR <span class="op">=</span> ((y_hat_LR <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>FP_LR <span class="op">=</span> ((y_hat_LR <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">0</span>)).<span class="bu">sum</span>()</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>TN_LR <span class="op">=</span> ((y_hat_LR <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">0</span>)).<span class="bu">sum</span>()</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>FN_LR <span class="op">=</span> ((y_hat_LR <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>PPV_LR <span class="op">=</span> TP_LR <span class="op">/</span> (y_hat_LR <span class="op">==</span> <span class="dv">1</span>).<span class="bu">sum</span>()</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>FPR_LR <span class="op">=</span> FP_LR <span class="op">/</span> (TP_LR <span class="op">+</span> FP_LR)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>FNR_LR <span class="op">=</span> FN_LR <span class="op">/</span> (TP_LR <span class="op">+</span> FN_LR)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Accuracy for Logistic Regression:</span><span class="sc">{</span>((y_hat_LR <span class="op">==</span> y_test).mean())<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"PPV for Logistic Regression:</span><span class="sc">{</span>PPV_LR<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall FPR for LR:</span><span class="sc">{</span>FPR_LR<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall FNR for LR:</span><span class="sc">{</span>FNR_LR<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Accuracy for Logistic Regression: 82.57%
PPV for Logistic Regression: 79.65%
Overall FPR for LR: 20.35%
Overall FNR for LR: 12.74%</code></pre>
</div>
</div>
<div id="cell-27" class="cell" data-execution_count="136">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Breaking down by subgroups is much easier if we use a Dataframe</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>df_test_LR <span class="op">=</span> pd.DataFrame(X_test, columns <span class="op">=</span> features_to_use1)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"group"</span>] <span class="op">=</span> group_test</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"label"</span>] <span class="op">=</span> y_test</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"predicted_value"</span>] <span class="op">=</span> y_hat_LR</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"correct_prediction"</span>] <span class="op">=</span> df_test_LR[<span class="st">"predicted_value"</span>] <span class="op">==</span> df_test_LR[<span class="st">"label"</span>]</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate correct prediction by group</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"correct_prediction"</span>] <span class="op">=</span> df_test_LR[<span class="st">"predicted_value"</span>] <span class="op">==</span> df_test_LR[<span class="st">"label"</span>]</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Accuracy By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_LR<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'correct_prediction'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate true positives and false positives by group</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"true_positive"</span>] <span class="op">=</span> (df_test_LR[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_LR[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_LR[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_LR[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate PPV by group</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>TP_per_group_LR <span class="op">=</span> df_test_LR.groupby(<span class="st">"group"</span>)[<span class="st">"true_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>FP_per_group_LR <span class="op">=</span> df_test_LR.groupby(<span class="st">"group"</span>)[<span class="st">"false_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>PPV_per_group <span class="op">=</span> TP_per_group_LR <span class="op">/</span> (TP_per_group_LR <span class="op">+</span> FP_per_group_LR)</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">PPV By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>PPV_per_group <span class="op">*</span> <span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate false positives by group</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_LR[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_LR[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>) </span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">FPR By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_LR<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'false_positive'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate false negatives by group</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>df_test_LR[<span class="st">"false_negative"</span>] <span class="op">=</span> (df_test_LR[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df_test_LR[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>) </span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">FNR By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_LR<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'false_negative'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute for statistical parity by group</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Total individuals per group</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>per_group_total_LR <span class="op">=</span> df_test_LR.groupby(<span class="st">"group"</span>)[<span class="st">"predicted_value"</span>].count()</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Total predicted positives per group</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>predicted_positives_per_group_LR <span class="op">=</span> df_test_LR.groupby(<span class="st">"group"</span>)[<span class="st">"predicted_value"</span>].<span class="bu">sum</span>()</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate acceptance rate</span></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>statistical_parity_by_group_LR <span class="op">=</span> (predicted_positives_per_group_LR <span class="op">/</span> per_group_total_LR) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Acceptance Rate (Employment) By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>statistical_parity_by_group_LR<span class="sc">}</span><span class="ss">%"</span>)</span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Accuracy By Group: 
 
 group
1    84.209040
2    81.011296
Name: correct_prediction, dtype: float64

PPV By Group: 
 group
1    83.887734
2    75.639764
dtype: float64

FPR By Group: 
 
 group
1     8.757062
2    13.313609
Name: false_positive, dtype: float64

FNR By Group: 
 
 group
1    7.033898
2    5.675094
Name: false_negative, dtype: float64

Acceptance Rate (Employment) By Group: 
 group
1    54.350282
2    54.653039
Name: predicted_value, dtype: float64%</code></pre>
</div>
</div>
<section id="discussion" class="level4">
<h4 class="anchored" data-anchor-id="discussion">Discussion:</h4>
<p>By implementing the PolynomialFeatures preprocessing function/module, I was able to add polynomial feature adjustments directly into the model pipeline. By calculating all polynomial combinations of my features with a degree of 2, I achieved my best accuracy of 82.57%.</p>
</section>
</section>
<section id="svc" class="level2">
<h2 class="anchored" data-anchor-id="svc">SVC</h2>
<div id="cell-30" class="cell" data-execution_count="137">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># SVC Classifier</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>model_sex_SVC <span class="op">=</span> make_pipeline(StandardScaler(), SVC(C <span class="op">=</span> <span class="fl">3.0</span>))</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>model_sex_SVC.fit(X_train, y_train)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>y_hat_SVC <span class="op">=</span> model_sex_SVC.predict(X_test)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate Overall Values</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>TP_SVC <span class="op">=</span> ((y_hat_SVC <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>FP_SVC <span class="op">=</span> ((y_hat_SVC <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">0</span>)).<span class="bu">sum</span>()</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>TN_SVC <span class="op">=</span> ((y_hat_SVC <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">0</span>)).<span class="bu">sum</span>()</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>FN_SVC <span class="op">=</span> ((y_hat_SVC <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>PPV_SVC <span class="op">=</span> TP_SVC <span class="op">/</span> (y_hat_SVC <span class="op">==</span> <span class="dv">1</span>).<span class="bu">sum</span>()</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>FPR_SVC <span class="op">=</span> FP_SVC <span class="op">/</span> (TP_SVC <span class="op">+</span> FP_SVC)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>FNR_SVC <span class="op">=</span> FN_SVC <span class="op">/</span> (TP_SVC <span class="op">+</span> FN_SVC)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Accuracy for SVC:</span><span class="sc">{</span>((y_hat_SVC <span class="op">==</span> y_test).mean())<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"PPV for SVC:</span><span class="sc">{</span>PPV_SVC<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall FPR for SVC:</span><span class="sc">{</span>FPR_SVC<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall FNR for SVC:</span><span class="sc">{</span>FNR_SVC<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Accuracy for SVC: 82.41%
PPV for SVC: 78.79%
Overall FPR for SVC: 21.21%
Overall FNR for SVC: 11.55%</code></pre>
</div>
</div>
<div id="cell-31" class="cell" data-execution_count="138">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Breaking down by subgroups is much easier if we use a Dataframe</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>df_test_SVC <span class="op">=</span> pd.DataFrame(X_test, columns <span class="op">=</span> features_to_use1)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"group"</span>] <span class="op">=</span> group_test</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"label"</span>] <span class="op">=</span> y_test</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"predicted_value"</span>] <span class="op">=</span> y_hat_SVC</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"correct_prediction"</span>] <span class="op">=</span> df_test_SVC[<span class="st">"predicted_value"</span>] <span class="op">==</span> df_test_SVC[<span class="st">"label"</span>]</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate correct prediction by group</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"correct_prediction"</span>] <span class="op">=</span> df_test_SVC[<span class="st">"predicted_value"</span>] <span class="op">==</span> df_test_SVC[<span class="st">"label"</span>]</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Accuracy By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_SVC<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'correct_prediction'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate true positives and false positives by group</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"true_positive"</span>] <span class="op">=</span> (df_test_SVC[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_SVC[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_SVC[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_SVC[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate PPV by group</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>TP_per_group_SVC <span class="op">=</span> df_test_SVC.groupby(<span class="st">"group"</span>)[<span class="st">"true_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>FP_per_group_SVC <span class="op">=</span> df_test_SVC.groupby(<span class="st">"group"</span>)[<span class="st">"false_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>PPV_per_group <span class="op">=</span> TP_per_group_SVC <span class="op">/</span> (TP_per_group_SVC <span class="op">+</span> FP_per_group_SVC)</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">PPV By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>PPV_per_group <span class="op">*</span> <span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate false positives by group</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_SVC[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_SVC[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>) </span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">FPR By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_SVC<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'false_positive'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate false negatives by group</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>df_test_SVC[<span class="st">"false_negative"</span>] <span class="op">=</span> (df_test_SVC[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df_test_SVC[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>) </span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">FNR By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_SVC<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'false_negative'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute for statistical parity by group</span></span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Total individuals per group</span></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>per_group_total_SVC <span class="op">=</span> df_test_SVC.groupby(<span class="st">"group"</span>)[<span class="st">"predicted_value"</span>].count()</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Total predicted positives per group</span></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>predicted_positives_per_group_SVC <span class="op">=</span> df_test_SVC.groupby(<span class="st">"group"</span>)[<span class="st">"predicted_value"</span>].<span class="bu">sum</span>()</span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate acceptance rate</span></span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a>statistical_parity_by_group_SVC <span class="op">=</span> (predicted_positives_per_group_SVC <span class="op">/</span> per_group_total_SVC) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Acceptance Rate (Employment) By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>statistical_parity_by_group_SVC<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Accuracy By Group: 
 group
1    84.406780
2    80.500269
Name: correct_prediction, dtype: float64

PPV By Group: 
 group
1    83.324860
2    74.508864
dtype: float64

FPR By Group: 
 group
1     9.265537
2    14.308768
Name: false_positive, dtype: float64

FNR By Group: 
 group
1    6.327684
2    5.190963
Name: false_negative, dtype: float64

Acceptance Rate (Employment) By Group: 
 group
1    55.564972
2    56.132329
Name: predicted_value, dtype: float64</code></pre>
</div>
</div>
<section id="discussion-1" class="level4">
<h4 class="anchored" data-anchor-id="discussion-1">Discussion:</h4>
<p>From what I could find on sklearn and online (this Medium article: https://medium.com/<span class="citation" data-cites="myselfaman12345/c-and-gamma-in-svm-e6cee48626be">@myselfaman12345/c-and-gamma-in-svm-e6cee48626be</span>) C - to put it generally - indicates <em>how much</em> we want to avoid misclassification on our training data. A low C value leads to low training error, and high C allows for more error on training data. However, minimizing C - and therefore training classification error - too far seems to lead to over fitting. As I dropped the C value below 1.0 (the default sklearn value) I found my classification accuracy begin to drop. Setting it too high led to the same effect. It seems that the “optimal” C value is context-dependent. Interestingly, my accuracy was very similary at a C value of 0.8 (82.35%) and 3.0 (82.41%). The default C value of 1.0 resulted in an 83.32% accuracy.</p>
<p><em>Extract predicitions on all test sets modeled with each classifier</em></p>
</section>
</section>
<section id="decision-tree" class="level2">
<h2 class="anchored" data-anchor-id="decision-tree">Decision Tree</h2>
<div id="cell-35" class="cell" data-execution_count="139">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Decision Tree Classifier</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>model_sex_DT <span class="op">=</span> make_pipeline(StandardScaler(), DecisionTreeClassifier(max_depth<span class="op">=</span><span class="dv">12</span>, min_samples_split<span class="op">=</span><span class="dv">8</span>))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>model_sex_DT.fit(X_train, y_train)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>y_hat_DT <span class="op">=</span> model_sex_DT.predict(X_test)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate Overall Values</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>TP_DT <span class="op">=</span> ((y_hat_DT <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>FP_DT <span class="op">=</span> ((y_hat_DT <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">0</span>)).<span class="bu">sum</span>()</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>TN_DT <span class="op">=</span> ((y_hat_DT <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">0</span>)).<span class="bu">sum</span>()</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>FN_DT <span class="op">=</span> ((y_hat_DT <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>PPV_DT <span class="op">=</span> TP_DT <span class="op">/</span> (y_hat_DT <span class="op">==</span> <span class="dv">1</span>).<span class="bu">sum</span>()</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>FPR_DT <span class="op">=</span> FP_DT <span class="op">/</span> (TP_DT <span class="op">+</span> FP_DT)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>FNR_DT <span class="op">=</span> FN_DT <span class="op">/</span> (TP_DT <span class="op">+</span> FN_DT)</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Accuracy for Decision Tree:</span><span class="sc">{</span>((y_hat_DT <span class="op">==</span> y_test).mean())<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="co"># No Parameters: 77.28%, With Parameters: 83.12% </span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"PPV for Decision Tree:</span><span class="sc">{</span>PPV_DT<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall FPR for Decision Tree:</span><span class="sc">{</span>FPR_DT<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall FNR for Decision Tree:</span><span class="sc">{</span>FNR_DT<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Accuracy for Decision Tree: 83.11%
PPV for Decision Tree: 80.41%
Overall FPR for Decision Tree: 19.59%
Overall FNR for Decision Tree: 12.68%</code></pre>
</div>
</div>
<div id="cell-36" class="cell" data-execution_count="140">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Breaking down by subgroups is much easier if we use a Dataframe</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>df_test_DT <span class="op">=</span> pd.DataFrame(X_test, columns <span class="op">=</span> features_to_use1)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"group"</span>] <span class="op">=</span> group_test</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"label"</span>] <span class="op">=</span> y_test</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"predicted_value"</span>] <span class="op">=</span> y_hat_DT</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"correct_prediction"</span>] <span class="op">=</span> df_test_DT[<span class="st">"predicted_value"</span>] <span class="op">==</span> df_test_DT[<span class="st">"label"</span>]</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate correct prediction by group</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"correct_prediction"</span>] <span class="op">=</span> df_test_DT[<span class="st">"predicted_value"</span>] <span class="op">==</span> df_test_DT[<span class="st">"label"</span>]</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Accuracy By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_DT<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'correct_prediction'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate true positives and false positives by group</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"true_positive"</span>] <span class="op">=</span> (df_test_DT[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_DT[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_DT[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_DT[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate PPV by group</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>TP_per_group_DT <span class="op">=</span> df_test_DT.groupby(<span class="st">"group"</span>)[<span class="st">"true_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>FP_per_group_DT <span class="op">=</span> df_test_DT.groupby(<span class="st">"group"</span>)[<span class="st">"false_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>PPV_per_group <span class="op">=</span> TP_per_group_DT <span class="op">/</span> (TP_per_group_DT <span class="op">+</span> FP_per_group_DT)</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">PPV By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>PPV_per_group <span class="op">*</span> <span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate false positives by group</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_DT[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_DT[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>) </span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">FPR By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_DT<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'false_positive'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate false negatives by group</span></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>df_test_DT[<span class="st">"false_negative"</span>] <span class="op">=</span> (df_test_DT[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df_test_DT[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>) </span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">FNR By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_DT<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'false_negative'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute for statistical parity by group</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Total individuals per group</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>per_group_total_DT <span class="op">=</span> df_test_DT.groupby(<span class="st">"group"</span>)[<span class="st">"predicted_value"</span>].count()</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Total predicted positives per group</span></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>predicted_positives_per_group_DT <span class="op">=</span> df_test_DT.groupby(<span class="st">"group"</span>)[<span class="st">"predicted_value"</span>].<span class="bu">sum</span>()</span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate acceptance rate</span></span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>statistical_parity_by_group_DT <span class="op">=</span> (predicted_positives_per_group_DT <span class="op">/</span> per_group_total_DT) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Acceptance Rate (Employment) By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>statistical_parity_by_group_DT<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Accuracy By Group: 
 group
1    85.084746
2    81.226466
Name: correct_prediction, dtype: float64

PPV By Group: 
 group
1    85.039370
2    76.041667
dtype: float64

FPR By Group: 
 group
1     8.050847
2    12.990855
Name: false_positive, dtype: float64

FNR By Group: 
 group
1    6.864407
2    5.782679
Name: false_negative, dtype: float64

Acceptance Rate (Employment) By Group: 
 group
1    53.813559
2    54.222700
Name: predicted_value, dtype: float64</code></pre>
</div>
</div>
<section id="discussion-2" class="level4">
<h4 class="anchored" data-anchor-id="discussion-2">Discussion:</h4>
<p>The Decision Tree Classifier achieved it’s highest accuracy of 83.12% with a max-depth of 12 and a min_samples_split - the minimum number of samples required to split an internal node - of 8. This classifier also ran the fasted of all the classifiers tested with parameters.</p>
</section>
</section>
<section id="random-forest" class="level2">
<h2 class="anchored" data-anchor-id="random-forest">Random Forest</h2>
<div id="cell-39" class="cell" data-execution_count="141">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Random Forest Classifier</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>model_sex_RF <span class="op">=</span> make_pipeline(StandardScaler(), RandomForestClassifier(n_estimators<span class="op">=</span><span class="dv">400</span>, max_depth<span class="op">=</span><span class="dv">16</span>))</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>model_sex_RF.fit(X_train, y_train)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>y_hat_RF <span class="op">=</span> model_sex_RF.predict(X_test)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate Overall Values</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>TP_RF <span class="op">=</span> ((y_hat_RF <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>FP_RF <span class="op">=</span> ((y_hat_RF <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">0</span>)).<span class="bu">sum</span>()</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>TN_RF <span class="op">=</span> ((y_hat_RF <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">0</span>)).<span class="bu">sum</span>()</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>FN_RF <span class="op">=</span> ((y_hat_RF <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (y_test <span class="op">==</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>PPV_RF <span class="op">=</span> TP_RF <span class="op">/</span> (y_hat_RF <span class="op">==</span> <span class="dv">1</span>).<span class="bu">sum</span>()</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>FPR_RF <span class="op">=</span> FP_RF <span class="op">/</span> (TP_RF <span class="op">+</span> FP_RF)</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>FNR_RF <span class="op">=</span> FN_RF <span class="op">/</span> (TP_RF <span class="op">+</span> FN_RF)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Accuracy for Random Forest:</span><span class="sc">{</span>((y_hat_RF <span class="op">==</span> y_test).mean())<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Without Parameters: 80.92%, With Parameters: 83.74%</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall PPV for Random Forest:</span><span class="sc">{</span>PPV_RF<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall FPR for Random Forest:</span><span class="sc">{</span>FPR_RF<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall FNR for Random Forest:</span><span class="sc">{</span>FNR_RF<span class="op">*</span><span class="dv">100</span><span class="sc">: .2f}</span><span class="ss">%"</span>)</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Accuracy for Random Forest: 83.70%
Overall PPV for Random Forest: 80.81%
Overall FPR for Random Forest: 19.19%
Overall FNR for Random Forest: 11.82%</code></pre>
</div>
</div>
<div id="cell-40" class="cell" data-execution_count="142">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Breaking down by subgroups is much easier if we use a Dataframe</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>df_test_RF <span class="op">=</span> pd.DataFrame(X_test, columns <span class="op">=</span> features_to_use1)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"group"</span>] <span class="op">=</span> group_test</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"label"</span>] <span class="op">=</span> y_test</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">=</span> y_hat_RF</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"correct_prediction"</span>] <span class="op">=</span> df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> df_test_RF[<span class="st">"label"</span>]</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate correct prediction by group</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"correct_prediction"</span>] <span class="op">=</span> df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> df_test_RF[<span class="st">"label"</span>]</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Accuracy By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_RF<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'correct_prediction'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate true positives and false positives by group</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"true_positive"</span>] <span class="op">=</span> (df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_RF[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_RF[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate PPV by group</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>TP_per_group_RF <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"true_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>FP_per_group_RF <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"false_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>PPV_per_group <span class="op">=</span> TP_per_group_RF <span class="op">/</span> (TP_per_group_RF <span class="op">+</span> FP_per_group_RF)</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">PPV By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>PPV_per_group <span class="op">*</span> <span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate false positives by group</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_RF[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>) </span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">FPR By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_RF<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'false_positive'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate false negatives by group</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"false_negative"</span>] <span class="op">=</span> (df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df_test_RF[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>) </span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">FNR By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>df_test_RF<span class="sc">.</span>groupby([<span class="st">'group'</span>])[<span class="st">'false_negative'</span>]<span class="sc">.</span>mean()<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute for statistical parity by group</span></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Total individuals per group</span></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>per_group_total_RF <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"predicted_value"</span>].count()</span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Total predicted positives per group</span></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>predicted_positives_per_group_RF <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"predicted_value"</span>].<span class="bu">sum</span>()</span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate acceptance rate</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>statistical_parity_by_group_RF <span class="op">=</span> (predicted_positives_per_group_RF <span class="op">/</span> per_group_total_RF) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Acceptance Rate (Employment) By Group: </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>statistical_parity_by_group_RF<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Accuracy By Group: 
 
 group
1    85.706215
2    81.791286
Name: correct_prediction, dtype: float64

PPV By Group: 
 group
1    85.356957
2    76.496784
dtype: float64

FPR By Group: 
 
 group
1     7.937853
2    12.775686
Name: false_positive, dtype: float64

FNR By Group: 
 
 group
1    6.355932
2    5.433029
Name: false_negative, dtype: float64

Acceptance Rate (Employment) By Group: 
 group
1    54.209040
2    54.357181
Name: predicted_value, dtype: float64</code></pre>
</div>
</div>
<section id="discussion-3" class="level4">
<h4 class="anchored" data-anchor-id="discussion-3">Discussion:</h4>
<p>While increasing max_depth to 16 itself led to the largest increase in classifier accuracy, adding more estimators - n_estimators set to 400 - to the model led to a further increase in accuracy from 83.55% to 83.74%. Random Forest achieved the highest prediction accuracy of all models tested.</p>
</section>
</section>
<section id="bias-measures" class="level2">
<h2 class="anchored" data-anchor-id="bias-measures">Bias Measures:</h2>
<ol type="1">
<li><p>A model is consider well calibrated if it reflects the same likelihood of positive prediction irrespective an individuals’ group membership. In other words, the model should be free from predictive bias. It appears that none of the models are well-calibrated as across all of them, the positive prediction rate of male employment is several percentage points higher than female employment. More specifically, the PPV ranges from anywhere between ~8%-9% across all of the models.</p></li>
<li><p>Across the board, again, the models do not satisfy error rate balance. The False Positive Rate (FPR) is higher for females across all four, whereas the False Negative Rate (FNR) is higher for males across all four models. Even further, the margin of difference between groups for FPR is much greater than that for FNR across all Models. The FPR difference between groups is at its lowest ~4.56% in our LR model, whereas the largest difference in FNRs is ~1.36%, also found in our LR model.</p></li>
<li><p>The best performing fairness metric across our models is statistical parity, with no models differing more than .7% in acceptance rate (i.e.&nbsp;employment prediction) between male and females.</p></li>
</ol>
</section>
<section id="plotting-feasible-fnr-and-fpr-rates" class="level2">
<h2 class="anchored" data-anchor-id="plotting-feasible-fnr-and-fpr-rates">Plotting Feasible FNR and FPR Rates</h2>
<p><em>Using Random Forest Model because it had the best accuracy per group</em></p>
<div id="cell-44" class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>prevalence <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"label"</span>].mean()</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>p_male <span class="op">=</span> prevalence.loc[<span class="dv">1</span>]</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>p_female <span class="op">=</span> prevalence.loc[<span class="dv">2</span>]</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Recalculating FNR here to make continuity more clear/avoid using variables from other cells</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate true positives and false positives by group</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"true_positive"</span>] <span class="op">=</span> (df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_RF[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"false_positive"</span>] <span class="op">=</span> (df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_test_RF[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"false_negative"</span>] <span class="op">=</span> (df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df_test_RF[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>df_test_RF[<span class="st">"true_negative"</span>] <span class="op">=</span> (df_test_RF[<span class="st">"predicted_value"</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df_test_RF[<span class="st">"label"</span>] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate PPV by group</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>TP_per_group_RF <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"true_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>FP_per_group_RF <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"false_positive"</span>].<span class="bu">sum</span>()</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>FN_per_group_RF <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"false_negative"</span>].<span class="bu">sum</span>()</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>TN_per_group_RF <span class="op">=</span> df_test_RF.groupby(<span class="st">"group"</span>)[<span class="st">"true_negative"</span>].<span class="bu">sum</span>()</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>PPV_per_group <span class="op">=</span> TP_per_group_RF <span class="op">/</span> (TP_per_group_RF <span class="op">+</span> FP_per_group_RF)</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>PPV_male <span class="op">=</span> PPV_per_group.loc[<span class="dv">1</span>]</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>PPV_female <span class="op">=</span> PPV_per_group.loc[<span class="dv">2</span>]</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate FNR</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>FNR <span class="op">=</span> FN_per_group_RF <span class="op">/</span> (FN_per_group_RF <span class="op">+</span> TP_per_group_RF)</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>FNR_male <span class="op">=</span> FNR.loc[<span class="dv">1</span>]</span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>FNR_female <span class="op">=</span> FNR.loc[<span class="dv">2</span>]</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate FPR</span></span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>FPR_male <span class="op">=</span> (p_male <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> p_male)) <span class="op">*</span> ((<span class="dv">1</span> <span class="op">-</span> PPV_male) <span class="op">/</span> PPV_male) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> FNR_male)</span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>FPR_female <span class="op">=</span> (p_female <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> p_female)) <span class="op">*</span> ((<span class="dv">1</span> <span class="op">-</span> PPV_female) <span class="op">/</span> PPV_female) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> FNR_female)</span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>feasible_FNR_range <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>FPR_male_line <span class="op">=</span> (p_male <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> p_male)) <span class="op">*</span> ((<span class="dv">1</span> <span class="op">-</span> PPV_female) <span class="op">/</span> PPV_female) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> feasible_FNR_range)</span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>FPR_female_line <span class="op">=</span> (p_female <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> p_female)) <span class="op">*</span> ((<span class="dv">1</span> <span class="op">-</span> PPV_female) <span class="op">/</span> PPV_female) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> feasible_FNR_range)</span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>plt.plot(FNR_male, FPR_male, <span class="st">'o'</span>, color<span class="op">=</span><span class="st">'orange'</span>, label<span class="op">=</span><span class="st">'Male'</span>)</span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>plt.plot(FNR_female, FPR_female, <span class="st">'o'</span>, color<span class="op">=</span><span class="st">'black'</span>, label<span class="op">=</span><span class="st">'Female'</span>)</span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>plt.plot(feasible_FNR_range, FPR_male_line, <span class="st">'-'</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>plt.plot(feasible_FNR_range, FPR_female_line, <span class="st">'-'</span>, color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"False Negative Rate (FNR)"</span>)</span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"False Positive Rate (FPR)"</span>)</span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Feasible FNRs and FPRs"</span>)</span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a>plt.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0.8535695674830641
0.7649678377041069</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-24-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Tuning the classifier threshold</strong>: Looking at the feasibility curves for males and females, if we set the threshold so that both groups have an FPR of 0.15, the male curve corresponds to an FNR of 0.25, while the female curve corresponds to an FNR of 0.40. Thus, to achieve the same FPR across groups, we must allow the female group’s FNR to increase from 0.25 to 0.40, a difference of 15%.</p>
</section>
<section id="concluding-discussion" class="level2">
<h2 class="anchored" data-anchor-id="concluding-discussion">Concluding Discussion:</h2>
<p><em>What groups of people could stand to benefit?</em></p>
<p>This model predicts whether an individual is employed, so it could benefit recruiting agencies or HR departments seeking to identify jobseekers or allocate training resources - specifically understanding what feature groups may be searching for a job/have more possible unemployed candidates available to interview.</p>
<p><em>Impact of deploying model?</em></p>
<p>From the bias audit, we see differences in false positive and false negative rates across groups. If deployed widely, these disparities could systematically disadvantage certain populations—for instance, if a higher false negative rate leads to fewer recognized as “employed,” those individuals might miss job opportunities or loans. Conversely, higher false positives could unfairly label individuals as employed when they are not, whereas false negatives could mean that hiring/search resources are allocated to the wrong demographic areas, disadvantaging those who don’t fit the template of an employed/unemployed individual. Even more, the differences in the bias audit reveal the way in which employment data is a proxy for historical prejudice - and in my case, specifically gender-based hiring prejudice - which could lead to reinforced stereotypes of who is “employable” and who is not.</p>
<p><em>Does the Model Display Bias?</em></p>
<p>From the bias audit (examining accuracy, PPV, FNR, and FPR by group), we see that the model’s performance differs between males and females for several fairness criterion. For example, it appears that none of the models are well-calibrated as across all we see the positive prediction rate of male employment is several percentage points higher than female employment. More specifically, the PPV ranges from anywhere between ~8%-9% across all of the models. There is also error rate imbalance: the False Positive Rate (FPR) is higher for females across all four, whereas the False Negative Rate (FNR) is higher for males across all four models. Even further, the margin of difference between groups for FPR is much greater than that for FNR across all Models. The FPR difference between groups is at its lowest ~4.56% in our LR model, whereas the largest difference in FNRs is ~1.36%, also found in our LR model. This could lead to prejudicial assumptions which have harmful effects on fair hiring practices. For instance, if one group has a statistically higher false negative rate, that group may be systematically overlooked for certain opportunities.</p>
<p><em>Further Concerns?</em></p>
<p>The model analyzed here is quite complex. Specifically, it involves the correlation/scoring of a large set of features, and classifier/modeling methods that are not very accessible. In other words, it isn’t a very transparent model, and that can lead to a lot of mistrust about how the decisions are being made and why. I also want to know more about <em>where</em> the data is being collected in a state, what areas/communities it is taken from, and how representative or random are those samples. To address these issues, we could continue ollect more diverse data, and promote education and transparency initiatives about Machine Learning. Furthermore, it is always important to include human oversight as a “second set of eyes” in decisions made about another person’s life from data.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>